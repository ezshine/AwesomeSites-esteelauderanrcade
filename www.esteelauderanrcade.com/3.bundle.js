(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{238:function(t,n,e){"use strict";e.d(n,"b",(function(){return o})),e.d(n,"a",(function(){return r}));var i=e(7);class o extends i.a{constructor(t,n){super(!0,!0),this.lights=[],this.shadowIndices=[],this.preCodeTemplate=n,this.codeTemplate=t}addLight(t){-1===this.lights.indexOf(t)&&(this.lights.push(t),this.shadowIndices.push(-1),this.invalidateCode())}removeLight(t){const n=this.lights.indexOf(t);n>-1&&(this.lights.splice(n,1),this.shadowIndices.splice(n,1),this.invalidateCode())}_genCode(t){if(0==this.lights.length)return;let n=this.preCodeTemplate({count:this.lights.length});t.add("pf",n),n="";for(var e=0;e<this.lights.length;e++)n+=this.genCodePerLights(this.lights[e],e,this.shadowIndices[e]);t.add("lightsf",n)}}class r extends o{setup(t){for(var n=0;n<this.shadowIndices.length;n++){var e=this.shadowIndices[n];if(e>-1){var i=this.lights[n].getShadowmap();t["tShadowMap"+e](i)}}}}},247:function(t,n,e){"use strict";e.d(n,"a",(function(){return r}));var i=e(90),o=e(33);class r extends i.a{constructor(t,n){super(),this._type=o.a.IBL,this.env=t,this.sh=n}setupProgram(t){t.tEnv&&t.tEnv(this.env),t.uSHCoeffs&&t.uSHCoeffs(this.sh)}static convert(t,n=1){const e=Math.sqrt(Math.PI),i=1/(2*e),o=Math.sqrt(3)/(3*e),r=Math.sqrt(15)/(8*e),a=Math.sqrt(5)/(16*e),s=.5*r,h=new Float32Array(28);return h[0]=n*(o*t[6]),h[1]=n*(-o*t[3]),h[2]=n*(-o*t[9]),h[3]=n*(i*t[0]-a*t[18]),h[4]=n*(o*t[7]),h[5]=n*(-o*t[4]),h[6]=n*(-o*t[10]),h[7]=n*(i*t[1]-a*t[19]),h[8]=n*(o*t[8]),h[9]=n*(-o*t[5]),h[10]=n*(-o*t[11]),h[11]=n*(i*t[2]-a*t[20]),h[12]=n*(r*t[12]),h[13]=n*(-r*t[15]),h[14]=n*(3*a*t[18]),h[15]=n*(-r*t[21]),h[16]=n*(r*t[13]),h[17]=n*(-r*t[16]),h[18]=n*(3*a*t[19]),h[19]=n*(-r*t[22]),h[20]=n*(r*t[14]),h[21]=n*(-r*t[17]),h[22]=n*(3*a*t[20]),h[23]=n*(-r*t[23]),h[24]=n*(s*t[24]),h[25]=n*(s*t[25]),h[26]=n*(s*t[26]),h[27]=1*n,h}}},273:function(t,n){var e=function(t){return"\n#ifndef _H_OCTWRAP_DECODE_\n#define _H_OCTWRAP_DECODE_\n\nvec2 octwrapDecode( vec3 v ) {\n  // Project the sphere onto the octahedron, and then onto the xy plan\n  vec2 p = v.xy / dot(  abs( v ) , vec3(1.0) );\n  p = vec2( p.x+p.y-1.0, p.x-p.y );\n\n  if( v.z < 0.0 )\n    p.x *= -1.0;\n\n  // p.x *= sign( v.z );\n  return p;\n}\n\n#endif","\n#ifndef _H_OCTWRAP_DECODE_\n#define _H_OCTWRAP_DECODE_\n\nvec2 octwrapDecode( vec3 v ) {\n  // Project the sphere onto the octahedron, and then onto the xy plan\n  vec2 p = v.xy / dot(  abs( v ) , vec3(1.0) );\n  p = vec2( p.x+p.y-1.0, p.x-p.y );\n\n  if( v.z < 0.0 )\n    p.x *= -1.0;\n\n  // p.x *= sign( v.z );\n  return p;\n}\n\n#endif"};e.toString=e,t.exports=e},274:function(t,n){var e=function(t){return"\n#ifndef _H_DECODE_RGBE_\n#define _H_DECODE_RGBE_\n\nvec3 decodeRGBE( vec4 hdr ){\n  return hdr.rgb * exp2( (hdr.a*255.0)-128.0 );\n  // return hdr.rgb * pow( 2.0, (hdr.a*255.0)-128.0 );\n}\n\n#endif","\n#ifndef _H_DECODE_RGBE_\n#define _H_DECODE_RGBE_\n\nvec3 decodeRGBE( vec4 hdr ){\n  return hdr.rgb * exp2( (hdr.a*255.0)-128.0 );\n  // return hdr.rgb * pow( 2.0, (hdr.a*255.0)-128.0 );\n}\n\n#endif"};e.toString=e,t.exports=e},275:function(t,n,e){"use strict";e.d(n,"a",(function(){return o}));var i=e(247);class o extends i.a{constructor(t,n,e){super(t,null),this.envHi=n,this.envBg=e}setupProgram(t){super.setupProgram(t),t.tEnvHi&&t.tEnvHi(this.envHi)}}},279:function(t,n,e){"use strict";e.d(n,"a",(function(){return h}));var i=e(222),o=e(398),r=e.n(o),a=e(399),s=e.n(a);class h extends i.b{constructor(t){super(),this.tint=[1,1,1],this.amount=t,this._preCode=r()(),this._code=s()()}genCode(t,n){t.push(this._preCode),n.push(this._code)}setupProgram(t){const n=this.amount,e=this.tint;t.uSaturation(e[0]*n,e[1]*n,e[2]*n)}init(){}release(){}preRender(){}resize(t,n){}}},291:function(t,n,e){"use strict";e.d(n,"a",(function(){return S}));var i=e(294),o=e(27),r=e(13),a=e(26),s=e(43),h=e(44),d=e(131),l=e.n(d),u=e(378),c=e.n(u),p=e(379),f=e.n(p),v=e(42),g=e(269),w=l.a.create();class _ extends v.a{constructor(){super({uid:"dpm",vert:c()(),frag:f()()}),this.version=this.inputs.add(new h.a("100")),this.precision=this.inputs.add(new s.a("mediump")),this.shaderid=this.inputs.add(new r.a("id_dpm",!0)),this.depthFormat=this.inputs.add(new a.a("depthFormat",g.a)),this.mask=-1}setLightSetup(t){this.inputs.remove(this.depthFormat),this.depthFormat.proxy(t.depthFormat),this.inputs.add(this.depthFormat)}prepare(t,n,e){t.uMVP&&(e.modelViewProjectionMatrix(w,n._wmatrix),t.uMVP(w)),t.uWorldMatrix&&t.uWorldMatrix(n._wmatrix),t.uVP&&t.uVP(e._viewProj)}}e(132);class S{constructor(t){this.scene=t;const n=t.gl;this.node=new o.a,this.setup=new i.a,this.setup.bounds.fromMinMax([-3,-3,-3],[3,3,3]),this.setup.stdModel.shadowFilter.set("PCF4x4"),this.setup.stdModel.iblShadowing.enable(),this.list=[];const e=new _;e.setLightSetup(this.setup),this.depthPass=e,this.depthCfg=t.glstate.config().cullFace(n.FRONT).enableCullface(!0).enableDepthTest(!0).depthMask(!0),this.controls=[]}registerLight(t){this.setup.add(t),this.list.push(t)}hasDepthShadowmap(){return!1}preRender(){for(var t of this.controls)t.update()}computeShadowmapBounds(){}}},294:function(t,n,e){"use strict";var i=e(26),o=e(89),r=e(13),a=e(7);const s=["PCFNONE","PCF4x1","PCF4x4","PCF2x2"];var h=e(367),d=e.n(h),l=e(368),u=e.n(l),c=e(369),p=e.n(c),f=e(370),v=e.n(f),g=e(371),w=e.n(g),_=e(372),S=e.n(_),m=e(373),x=e.n(m),C=e(374),D=e.n(C),P=e(375),L=e.n(P),y=e(376),T=e.n(y),M=e(377),O=e.n(M),F=e(33),E=e(238);class b extends E.a{constructor(t,n){super(t,n),this.type=F.a.DIRECTIONAL,this._directions=null,this._colors=null}genCodePerLights(t,n,e){var i={index:n,shadowIndex:e};return this.codeTemplate(i)}allocate(t){null!==this._colors&&this._colors.length/4===t||(this._directions=new Float32Array(3*t),this._colors=new Float32Array(4*t))}prepare(t,n){var e=this.lights;this.allocate(e.length);for(var i=0;i<e.length;i++){var o=e[i];if(this._directions.set(o._wdir,3*i),this._colors.set(o._color,4*i),this._colors[4*i+3]=o.iblShadowing,o._castShadows){o.initShadowmap(t);var r=n.shadowChunk.addLight(o);this.shadowIndices[i]!==r&&this.invalidateCode(),this.shadowIndices[i]=r}else this.shadowIndices[i]=-1}this._invalid=!0}setup(t){this.lights.length>0&&(super.setup(t),t.uLDirDirections(this._directions),t.uLDirColors(this._colors),this._invalid=!1)}}class z extends E.a{constructor(t,n){super(t,n),this.type=F.a.SPOT,this._positions=null,this._directions=null,this._colors=null,this._attenuation=null}genCodePerLights(t,n,e){var i={index:n,shadowIndex:e,infinite:t.radius<=0};return this.codeTemplate(i)}allocate(t){null!==this._colors&&this._colors.length/4===t||(this._positions=new Float32Array(3*t),this._directions=new Float32Array(3*t),this._colors=new Float32Array(4*t),this._attenuation=new Float32Array(4*t))}prepare(t,n){const e=this.lights;this.allocate(e.length);for(var i=0;i<e.length;i++){var o=e[i];if(this._positions.set(o._wposition,3*i),this._directions.set(o._wdir,3*i),this._colors.set(o._color,4*i),this._attenuation.set(o._attenuationData,4*i),this._colors[4*i+3]=o.iblShadowing,o._castShadows){o.initShadowmap(t);var r=n.shadowChunk.addLight(o);this.shadowIndices[i]!==r&&this.invalidateCode(),this.shadowIndices[i]=r}else this.shadowIndices[i]=-1}this._invalid=!0}setup(t){this.lights.length>0&&(super.setup(t),t.uLSpotPositions(this._positions),t.uLSpotDirections(this._directions),t.uLSpotColors(this._colors),t.uLSpotAttenuation(this._attenuation),this._invalid=!1)}}class I extends E.b{constructor(t,n){super(t,n),this.type=F.a.POINT,this._colors=null,this._positions=null}genCodePerLights(t,n,e){var i={index:n,shadowIndex:e,infinite:t.radius<=0};return this.codeTemplate(i)}allocate(t){null!==this._colors&&this._colors.length/3===t||(this._colors=new Float32Array(3*t),this._positions=new Float32Array(4*t))}prepare(t,n){const e=this.lights;this.allocate(e.length);for(var i=0;i<e.length;i++){var o=e[i];this._colors.set(o._color,3*i),this._positions.set(o._wposition,4*i),this._positions[4*i+3]=1/(o.radius*o.radius),this.shadowIndices[i]=-1}this._invalid=!0}setup(t){this.lights.length>0&&(super.setup(t),t.uLPointColors(this._colors),t.uLPointPositions(this._positions),this._invalid=!1)}}class A extends E.b{constructor(t,n){super(t,n),this.type=F.a.IBL}genCodePerLights(t,n,e){return this.codeTemplate(this)}prepare(t,n){}addLight(t){if(this.lights.length>0)throw new Error("IblModel support only one Ibl Light");super.addLight(t)}setup(t){if(this.lights.length>0){const n=this.lights[0];t.tEnv&&t.tEnv(n.env),t.uSHCoeffs&&t.uSHCoeffs(n.sh)}}}class B{constructor(){this.dirPreCode=d.a,this.spotPreCode=u.a,this.pointPreCode=p.a,this.dirLightCode=v.a,this.spotLightCode=w.a,this.pointLightCode=S.a,this.shadPreCode=x.a,this.preLightCode=D.a,this.postLightCode=L.a,this.iblPreCode=T.a,this.iblCode=O.a}}class H extends a.a{constructor(t){super(!0,!1),this.code=t}_genCode(t){t.add("lightsf",this.code(this))}}class N extends a.a{constructor(t){super(!0,!1),this.code=t}_genCode(t){t.add("lightsf",this.code(this))}}const R=Math.PI/4;class V extends a.a{constructor(t){super(!0,!0),this.lightModel=t,this.shadowCount=0,this.genCount=0,this._matrices=new Float32Array(64),this._texelBiasVector=new Float32Array(16),this._shadowmapSizes=new Float32Array(8),this._umatrices=null,this._utexelBiasVector=null,this._ushadowmapSizes=null}_genCode(t){this.shadowCount>0&&t.add("pf",this.lightModel.modelCode.shadPreCode(this))}addLight(t){const n=this.shadowCount,e=this.lightModel.getLightSetup();this.shadowCount++,this._matrices.set(t.getShadowProjection(e.bounds),16*n),this._texelBiasVector.set(t.getTexelBiasVector(),4*n);const i=t.getShadowmapSize();if(this._shadowmapSizes[2*n+0]=i,this._shadowmapSizes[2*n+1]=1/i,0===n){var o=t.hasDepthShadowmap();e.depthFormat.set(o?"D_DEPTH":"D_RGB")}return n}check(){this.genCount!==this.shadowCount&&(this.genCount=this.shadowCount,this._umatrices=new Float32Array(this._matrices.buffer,0,16*this.shadowCount),this._utexelBiasVector=new Float32Array(this._texelBiasVector.buffer,0,4*this.shadowCount),this._ushadowmapSizes=new Float32Array(this._shadowmapSizes.buffer,0,2*this.shadowCount),this.invalidateCode()),this._invalid=!0}setup(t){this.shadowCount>0&&(t.uShadowMatrices(this._umatrices),t.uShadowTexelBiasVector(this._utexelBiasVector),t.uShadowMapSize(this._ushadowmapSizes),void 0!==t.uShadowKernelRotation&&t.uShadowKernelRotation(1*Math.cos(R),1*Math.sin(R)),this._invalid=!1)}}var W=class{constructor(t){void 0===t&&(t=new B),this.modelCode=t,this._datas={},this._dataList=[],this._setup=null,this.preLightsChunk=new H(this.modelCode.preLightCode),this.postLightsChunk=new N(this.modelCode.postLightCode),this.shadowChunk=new V(this),this.shadowFilter=new i.a("shadowFilter",s),this.iblShadowing=new r.a("iblShadowing",!1),this.registerLightModel(new I(t.pointLightCode,t.pointPreCode)),this.registerLightModel(new z(t.spotLightCode,t.spotPreCode)),this.registerLightModel(new b(t.dirLightCode,t.dirPreCode)),this.registerLightModel(new A(t.iblCode,t.iblPreCode))}registerLightModel(t){this._datas[t.type]=t,this._dataList.push(t)}getLightSetup(){return this._setup}setLightSetup(t){this._setup=t}add(t){this._datas[t._type].addLight(t)}remove(t){this._datas[t._type].removeLight(t)}prepare(t){this.shadowChunk.shadowCount=0;for(var n=0;n<this._dataList.length;n++)this._dataList[n].prepare(t,this);this.shadowChunk.check()}getChunks(){const t=[this.iblShadowing,this.shadowFilter,this.shadowChunk,this.preLightsChunk];for(var n=0;n<this._dataList.length;n++)t.push(this._dataList[n]);return t.push(this.postLightsChunk),t}},G=e(269);n.a=class{constructor(){this._lights=[],this._models=[],this._modelsMap={},this.depthFormat=new i.a("depthFormat",G.a),this.bounds=new o.a,this.stdModel=new W,this._registerModel("std",this.stdModel)}add(t){if(-1===this._lights.indexOf(t)){this._lights.push(t);for(var n=0;n<this._models.length;n++)this._models[n].add(t)}}remove(t){var n=this._lights.indexOf(t);if(n>-1)for(this._lights.splice(n,1),n=0;n<this._models.length;n++)this._models[n].remove(t)}prepare(t){for(var n=0;n<this._models.length;n++)this._models[n].prepare(t)}getChunks(t){void 0===t&&(t="std");var n=this._modelsMap[t].getChunks();return n.unshift(this.depthFormat),n}_registerModel(t,n){if(void 0===this._modelsMap[t]){this._modelsMap[t]=n,this._models.push(n),n.setLightSetup(this);for(var e=0;e<this._lights.length;e++)n.add(this._lights[e])}}}},367:function(t,n){var e=function(t){var n="";return n+="#define NUM_D_LIGHTS "+t.count+"\n\n",t.count>0&&(n+="\nuniform vec3 uLDirDirections [NUM_D_LIGHTS];\nuniform vec4 uLDirColors     [NUM_D_LIGHTS]; // rgb + iblShadowing\n"),n+="\n\n"};e.toString=e,t.exports=e},368:function(t,n){var e=function(t){var n="";return n+="#define NUM_S_LIGHTS "+t.count+"\n\n",t.count>0&&(n+="\nuniform vec3 uLSpotPositions  [NUM_S_LIGHTS];\nuniform vec3 uLSpotDirections [NUM_S_LIGHTS];\nuniform vec4 uLSpotColors     [NUM_S_LIGHTS]; // rgb + iblShadowing\nuniform vec4 uLSpotAttenuation[NUM_S_LIGHTS]; \n"),n+="\n\n"};e.toString=e,t.exports=e},369:function(t,n){var e=function(t){var n="";return n+="#define NUM_P_LIGHTS "+t.count+"\n\n",t.count>0&&(n+="\nuniform vec4 uLPointPositions  [NUM_P_LIGHTS]; //w is radius\nuniform vec3 uLPointFalloff    [NUM_P_LIGHTS];\nuniform vec3 uLPointColors     [NUM_P_LIGHTS]; // rgb\n"),n+="\n\n"};e.toString=e,t.exports=e},370:function(t,n){var e=function(t){var n="";return n+="\n{\n  Light light;\n\n  light.direction = uLDirDirections  ["+t.index+"]    ;\n  light.color     = uLDirColors      ["+t.index+"].rgb;\n  light.attenuation = 1.0;\n\n  ",t.shadowIndex>-1?n+="\n    ShadowMapData shadowmapData = GET_SHADOWMAP_DATA( "+t.shadowIndex+" );\n    light.shadowAttenuation = SampleShadowAttenuation(shadowmapData, tShadowMap"+t.shadowIndex+", inputData.worldPos, inputData.worldNrm );\n  ":n+="\n    light.shadowAttenuation = 1.0;\n  ",n+="\n  \n  // TODO store ibl contrib in separate struct\n  // #if iblShadowing\n  //   float sDamp = uLDirColors["+t.index+"].a;\n  //   specularColor *= mix( sDamp, 1.0, shOccl );\n  // #endif\n\n  color += LightingPhysicallyBased(brdfData, light, inputData.worldNrm, inputData.viewDir);\n}"};e.toString=e,t.exports=e},371:function(t,n){var e=function(t){var n="";return n+="\n{\n  vec3 lightPositionWS                    = uLSpotPositions  ["+t.index+"]    ;\n  mediump vec3 spotDirection              = uLSpotDirections ["+t.index+"]    ;\n  mediump vec3 lightColor                 = uLSpotColors     ["+t.index+"].rgb;\n  mediump vec4 distanceAndSpotAttenuation = uLSpotAttenuation["+t.index+"]    ;\n\n  vec3 lightVector = lightPositionWS - inputData.worldPos;\n  float distanceSqr = dot(lightVector, lightVector);\n\n  mediump vec3 lightDirection = vec3(lightVector * inversesqrt(distanceSqr));\n\n  mediump float attenuation = AngleAttenuation(spotDirection.xyz, lightDirection, distanceAndSpotAttenuation.zw);\n  ",t.infinite?n+="\n    attenuation *= DistanceAttenuation(distanceSqr);\n  ":n+="\n    attenuation *= DistanceAttenuationRange(distanceSqr, distanceAndSpotAttenuation.xy);\n  ",n+="\n\n\n  Light light;\n  light.direction = lightDirection;\n  light.attenuation = attenuation;\n  light.color = lightColor;\n\n  ",t.shadowIndex>-1?n+="\n    ShadowMapData shadowmapData = GET_SHADOWMAP_DATA( "+t.shadowIndex+" );\n    light.shadowAttenuation = SampleShadowAttenuation(shadowmapData, tShadowMap"+t.shadowIndex+", inputData.worldPos, inputData.worldNrm );\n  ":n+="\n    light.shadowAttenuation = 1.0;\n  ",n+="\n  \n  // TODO store ibl contrib in separate struct\n  // #if iblShadowing\n  //   float sDamp = uLSpotColors["+t.index+"].a;\n  //   specularColor *= mix( sDamp, 1.0, shOccl );\n  // #endif\n\n  \n  // mediump vec3 attenuatedLightColor = light.color * (light.attenuation * light.shadowAttenuation);\n  // LS_DIFFUSE  += LightingLambert(attenuatedLightColor, light.direction, inputData.worldNrm);\n  // LS_SPECULAR += LightingSpecular(attenuatedLightColor, light.direction, inputData.worldNrm, inputData.viewDir, specularGloss, smoothness);\n\n  color += LightingPhysicallyBased(brdfData, light, inputData.worldNrm, inputData.viewDir);\n}"};e.toString=e,t.exports=e},372:function(t,n){var e=function(t){var n="";return n+="\n{\n  vec3 lightPositionWS                    = uLPointPositions ["+t.index+"].xyz;\n  mediump vec3 lightColor                 = uLPointColors    ["+t.index+"].rgb;\n\n  vec3 lightVector = lightPositionWS - inputData.worldPos;\n  float distanceSqr = dot(lightVector, lightVector);\n\n  mediump vec3 lightDirection = vec3(lightVector * inversesqrt(distanceSqr));\n\n  ",t.infinite?n+="\n    mediump float attenuation = DistanceAttenuation(distanceSqr);\n  ":n+="\n    float oneOverRangeSquared = uLPointPositions["+t.index+"].w;\n    mediump float attenuation = DistanceAttenuationRange(distanceSqr, vec2(oneOverRangeSquared, 0.0));\n  ",n+="\n\n\n  Light light;\n  light.direction = lightDirection;\n  light.attenuation = attenuation;\n  light.color = lightColor;\n  light.shadowAttenuation = 1.0;\n\n  color += LightingPhysicallyBased(brdfData, light, inputData.worldNrm, inputData.viewDir);\n}"};e.toString=e,t.exports=e},373:function(t,n){var e=function(t){var n="";n+="\n\n#define SHADOW_COUNT "+t.shadowCount+"\n\n#if __VERSION__ == 300\n  precision lowp sampler2DShadow;\n\n  #define DepthSampler sampler2DShadow\n  \n#else\n  #define DepthSampler sampler2D\n#endif\n\n\n";for(var e=0;e<t.shadowCount;e++)n+="\n  uniform DepthSampler tShadowMap"+e+";\n";return n+="\n\n\n\n\nuniform highp vec2 uShadowKernelRotation;\nuniform highp mat4 uShadowMatrices[SHADOW_COUNT];\nuniform highp vec4 uShadowTexelBiasVector[SHADOW_COUNT];\nuniform       vec2 uShadowMapSize[SHADOW_COUNT];\n\n\nstruct ShadowMapData {\n  mat4 projection;\n  vec4 texelBiasVector;\n  vec2 size; // size , 1/size\n};\n\n#define GET_SHADOWMAP_DATA(i) ShadowMapData( uShadowMatrices[i], uShadowTexelBiasVector[i], uShadowMapSize[i])\n\n\n// RGB depth decoding\n// ------------------\nhighp float decodeDepthRGB(highp vec3 rgb){\n  return(rgb.x+rgb.y*(1.0/255.0))+rgb.z*(1.0/65025.0);\n}\n\n\n#if __VERSION__ == 300\n  \n      \n  float textureShadow( DepthSampler t, float ref, vec2 uvs ){\n    return texture(t, vec3( uvs, ref ) );\n  }\n\n  vec2 textureShadow( DepthSampler t, float ref, vec4 uvs ){\n    \n    return vec2(\n      texture(t, vec3( uvs.xy, ref ) ),\n      texture(t, vec3( uvs.zw, ref ) )\n    );\n\n  }\n\n  vec4 textureShadow( DepthSampler t, float ref, vec4 uvs0, vec4 uvs1 ){\n    \n    return vec4(\n      texture(t, vec3( uvs0.xy, ref ) ),\n      texture(t, vec3( uvs0.zw, ref ) ),\n      texture(t, vec3( uvs1.xy, ref ) ),\n      texture(t, vec3( uvs1.zw, ref ) )\n    );\n\n  }\n\n\n\n#else\n\n\n\n  #if depthFormat( D_RGB )\n    float FETCH_DEPTH( DepthSampler t, vec2 uvs ){\n      return decodeDepthRGB( texture2D(t,uvs).xyz );\n    }\n    //define FETCH_DEPTH(t,uvs) decodeDepthRGB( texture2D(t,uvs).xyz )\n  #endif\n\n  #if depthFormat( D_DEPTH )\n    float FETCH_DEPTH( DepthSampler t, vec2 uvs ){\n      return texture2D(t,uvs).x;\n    }\n    //define FETCH_DEPTH(t,uvs) texture2D(t,uvs).x\n  #endif\n\n  \n  float textureShadow( DepthSampler t, float ref, vec2 uvs ){\n    return step( ref, FETCH_DEPTH(t,uvs));\n  }\n\n  vec2 textureShadow( DepthSampler t, float ref, vec4 uvs ){\n    \n    vec2 occl = vec2(\n      FETCH_DEPTH(t,uvs.xy),\n      FETCH_DEPTH(t,uvs.zw)\n    );\n\n    return step( vec2(ref), occl );\n  }\n\n  vec4 textureShadow( DepthSampler t, float ref, vec4 uvs0, vec4 uvs1 ){\n    \n    vec4 occl = vec4(\n      FETCH_DEPTH(t,uvs0.xy),\n      FETCH_DEPTH(t,uvs0.zw),\n      FETCH_DEPTH(t,uvs1.xy),\n      FETCH_DEPTH(t,uvs1.zw)\n    );\n\n    return step( vec4(ref), occl );\n  }\n\n#endif\n\n\n\n\n\n\n\nfloat resolveShadowNoFiltering(highp float fragZ, DepthSampler depth,highp vec2 uv ){\n    return textureShadow( depth, fragZ, uv );\n}\n\n\n#if __VERSION__ == 300\n  // Bilinear is natively supported in ES3\n  // Shadowmap filtering must be set by sampler2DShadow filter parameter\n\n  float resolveShadow2x1(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n    return textureShadow( depth, fragZ, uv );\n  }\n\n  float resolveShadow2x2(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n    return textureShadow( depth, fragZ, uv );\n  }\n\n#else\n\n  float resolveShadow2x1(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n\n    highp float coordsPx = uv.x*mapSize.x;\n    highp float uvMin = floor( coordsPx ) * mapSize.y;\n    highp float uvMax = ceil(  coordsPx ) * mapSize.y;\n\n    vec2 occl = textureShadow( depth, fragZ, vec4(\n      uvMin,uv.y,\n      uvMax,uv.y\n    ));\n\n    highp float ratio = coordsPx - uvMin*mapSize.x;\n    return ( ratio * occl.y + occl.x ) - ratio * occl.x;\n\n  }\n\n  float resolveShadow2x2(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n\n    highp vec2 coordsPx = uv*mapSize.x;\n    highp vec2 uvMin=floor( coordsPx ) *mapSize.y;\n    highp vec2 uvMax=ceil(  coordsPx ) *mapSize.y;\n\n    vec4 occl = textureShadow( depth, fragZ, \n      vec4(\n        uvMin,\n        vec2(uvMax.x,uvMin.y)\n      ),\n      vec4(\n        vec2(uvMin.x,uvMax.y),\n        uvMax\n      )\n    );\n\n    highp vec2 ratio = coordsPx - uvMin*mapSize.x;\n    vec2  t = ( ratio.y * occl.zw + occl.xy ) - ratio.y * occl.xy;\n\n    return(ratio.x*t.y+t.x)-ratio.x*t.x;\n  }\n\n#endif\n\n\nfloat calcLightOcclusions(DepthSampler depth, highp vec3 fragCoord, vec2 mapSize ){\n  float s;\n\n  highp vec2 kernelOffset = uShadowKernelRotation * mapSize.y;\n\n  // NO FILTER\n  #if shadowFilter( PCFNONE )\n\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy );\n  #endif\n\n  // PCF4x1\n  #if shadowFilter( PCF4x1 )\n\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + kernelOffset                    );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy - kernelOffset                    );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x)  );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x)  );\n    s /= 4.0;\n  #endif\n\n  // PCF4x4\n  #if shadowFilter( PCF4x4 )\n\n    s = resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + kernelOffset                         , mapSize );\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy - kernelOffset                         , mapSize );\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x) , mapSize );\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x) , mapSize );\n    s /= 4.0;\n  #endif\n\n  // PCF2x2\n  #if shadowFilter( PCF2x2 )\n\n    s = resolveShadow2x1( fragCoord.z, depth, fragCoord.xy + kernelOffset , mapSize);\n    s+= resolveShadow2x1( fragCoord.z, depth, fragCoord.xy - kernelOffset , mapSize);\n    s /= 2.0;\n  #endif\n\n\n  if( any( greaterThan( abs( fragCoord - vec3(.5) ), vec3(.5) ) ) ){\n    s = 1.0;\n  }\n\n  return s;\n\n}\n\n// float3 ApplyShadowBias(float3 positionWS, float3 normalWS, float3 lightDirection)\n// {\n//     float invNdotL = 1.0 - saturate(dot(lightDirection, normalWS));\n//     float scale = invNdotL * _ShadowBias.y;\n\n//     // normal bias is negative since we want to apply an inset normal offset\n//     positionWS = lightDirection * _ShadowBias.xxx + positionWS;\n//     positionWS = normalWS * scale.xxx + positionWS;\n//     return positionWS;\n// }\n\nvec3 calcShadowPosition( vec4 texelBiasVector, mat4 shadowProjection, vec3 worldPos, vec3 worldNormal, float invMapSize )\n{\n  float WoP = dot( texelBiasVector, vec4( worldPos, 1.0 ) );\n\n  WoP *= .0005+2.0*invMapSize;\n\n  highp vec4 fragCoord = shadowProjection * vec4( worldPos + WoP * worldNormal, 1.0);\n  return fragCoord.xyz / fragCoord.w;\n}\n\n\n\nvec3 calcShadowPosition( ShadowMapData shadowmap, vec3 worldPos, vec3 worldNormal )\n{\n  float WoP = dot( shadowmap.texelBiasVector, vec4( worldPos, 1.0 ) );\n\n  WoP *= .005+2.0*shadowmap.size.y;\n\n  highp vec4 fragCoord = shadowmap.projection * vec4( worldPos + WoP * worldNormal, 1.0);\n  return fragCoord.xyz / fragCoord.w;\n}\n\n\nmediump float SampleShadowAttenuation( ShadowMapData shadowmap, DepthSampler texture, vec3 worldPos, vec3 worldNormal  ) {\n  highp vec3 coords = calcShadowPosition( shadowmap, worldPos, worldNormal );\n  return calcLightOcclusions( texture, coords, shadowmap.size );\n}"};e.toString=e,t.exports=e},374:function(t,n){var e=function(t){return"",""};e.toString=e,t.exports=e},375:function(t,n){var e=function(t){return"\n// post light setup\n// todo: should not be\n// specularColor += lSpecularColor * input.specularF0;","\n// post light setup\n// todo: should not be\n// specularColor += lSpecularColor * input.specularF0;"};e.toString=e,t.exports=e},376:function(t,n,e){var i=function(t){var n="";return n+="\n\n#ifndef _H_SPECULAR_IBL_\n#define _H_SPECULAR_IBL_\n\n\n"+e(273)()+"\n"+e(274)()+"\n\n\n\n// IBL\n// ========\nuniform sampler2D tEnv;\n\n\n\n#if perVertexIrrad\n  IN vec3 vIrradiance;\n#else\n  uniform vec4 uSHCoeffs[7];\n  "+e(127)()+"\n#endif\n\n\n\nconst vec2 _IBL_UVM = vec2(\n  0.25*(254.0/256.0),\n  0.125*0.5*(254.0/256.0)\n);\n\n\n\nvec3 SpecularIBL( sampler2D tEnv, vec3 skyDir, float roughness)\n{\n\n  vec2 uvA = octwrapDecode( skyDir );\n\n  float r7   = 7.0*roughness;\n  float frac = fract(r7);\n\n  uvA = uvA * _IBL_UVM + vec2(\n      0.5,\n      0.125*0.5 + 0.125 * ( r7 - frac )\n    );\n\n  #if glossNearest\n\n    return decodeRGBE( texture2D(tEnv,uvA) );\n\n  #else\n\n    vec2 uvB=uvA+vec2(0.0,0.125);\n    return  mix(\n      decodeRGBE( texture2D(tEnv,uvA) ),\n      decodeRGBE( texture2D(tEnv,uvB) ),\n      frac\n    );\n\n  #endif\n\n}\n\n\n\nvec3 ComputeIBLDiffuse( vec3 worldNormal ){\n  #if perVertexIrrad\n    return vIrradiance;\n  #else\n    return SampleSH(worldNormal, uSHCoeffs );\n  #endif\n}\n\n#endif"};i.toString=i,t.exports=i},377:function(t,n){var e=function(t){return"\n// IBL \n{\n  LS_DIFFUSE  += ComputeIBLDiffuse( inputData.worldNrm );\n  LS_SPECULAR += SpecularIBL( tEnv, worldReflect, brdfData.perceptualRoughness );\n}\n","\n// IBL \n{\n  LS_DIFFUSE  += ComputeIBLDiffuse( inputData.worldNrm );\n  LS_SPECULAR += SpecularIBL( tEnv, worldReflect, brdfData.perceptualRoughness );\n}\n"};e.toString=e,t.exports=e},378:function(t,n){var e=function(t){return"\n#pragma SLOT definitions\n#pragma SLOT precision\n\n\n#if __VERSION__ == 300\n  #define IN in\n  #define OUT out\n#else\n  #define IN attribute\n  #define OUT varying\n#endif\n\n\n#pragma SLOT pv\n\nattribute vec3 aPosition;\n\n\nuniform mat4 uMVP;\nuniform mat4 uWorldMatrix;\nuniform mat4 uVP;\n\n\n#if depthFormat( D_RGB )\n  varying vec2 fragZW;\n#endif\n\n\nvoid main(void){\n\n  #pragma SLOT v\n\n  // warp acces\n  vec3 pos = aPosition;\n  vec3 nrm = vec3(0.0);\n  mat4 worldMatrix = uWorldMatrix;\n  mat4 mvp         = uMVP;\n\n  #pragma SLOT vertex_warp\n\n  vec4 worldPos = worldMatrix * vec4( pos, 1.0 );\n  worldPos.xyz /= worldPos.w;\n  worldPos.w = 1.0;\n\n  #pragma SLOT vertex_warp_world\n\n  gl_Position     = uVP         * worldPos;\n\n  #if depthFormat( D_RGB )\n    fragZW=gl_Position.zw;\n  #endif\n}\n","\n#pragma SLOT definitions\n#pragma SLOT precision\n\n\n#if __VERSION__ == 300\n  #define IN in\n  #define OUT out\n#else\n  #define IN attribute\n  #define OUT varying\n#endif\n\n\n#pragma SLOT pv\n\nattribute vec3 aPosition;\n\n\nuniform mat4 uMVP;\nuniform mat4 uWorldMatrix;\nuniform mat4 uVP;\n\n\n#if depthFormat( D_RGB )\n  varying vec2 fragZW;\n#endif\n\n\nvoid main(void){\n\n  #pragma SLOT v\n\n  // warp acces\n  vec3 pos = aPosition;\n  vec3 nrm = vec3(0.0);\n  mat4 worldMatrix = uWorldMatrix;\n  mat4 mvp         = uMVP;\n\n  #pragma SLOT vertex_warp\n\n  vec4 worldPos = worldMatrix * vec4( pos, 1.0 );\n  worldPos.xyz /= worldPos.w;\n  worldPos.w = 1.0;\n\n  #pragma SLOT vertex_warp_world\n\n  gl_Position     = uVP         * worldPos;\n\n  #if depthFormat( D_RGB )\n    fragZW=gl_Position.zw;\n  #endif\n}\n"};e.toString=e,t.exports=e},379:function(t,n){var e=function(t){return"\n#pragma SLOT definitions\n#pragma SLOT precision\n\n\n#if __VERSION__ == 300\n  #define IN in\n#else\n  #define IN varying\n#endif\n\n#pragma SLOT pf\n\n\n\n#if depthFormat( D_RGB )\n  varying vec2 fragZW;\n\n  vec3 encodeDepthRGB(float depth){\n    vec4 c = vec4(1.0,255.0,65025.0,16581375.0)*depth;\n    c=fract(c);\n    c.xyz-=c.yzw*(1.0/255.0);\n    return c.xyz;\n  }\n#endif\n\n\n\nvoid main(void){\n\n  #pragma SLOT f\n  \n  #if depthFormat( D_RGB )\n    gl_FragColor.xyz = encodeDepthRGB( ( fragZW.x / fragZW.y ) * 0.5 + 0.5 );\n    gl_FragColor.w=0.0;\n  #endif\n\n  #if depthFormat( D_DEPTH )\n    gl_FragColor = vec4( 0.0 );\n  #endif\n\n}\n","\n#pragma SLOT definitions\n#pragma SLOT precision\n\n\n#if __VERSION__ == 300\n  #define IN in\n#else\n  #define IN varying\n#endif\n\n#pragma SLOT pf\n\n\n\n#if depthFormat( D_RGB )\n  varying vec2 fragZW;\n\n  vec3 encodeDepthRGB(float depth){\n    vec4 c = vec4(1.0,255.0,65025.0,16581375.0)*depth;\n    c=fract(c);\n    c.xyz-=c.yzw*(1.0/255.0);\n    return c.xyz;\n  }\n#endif\n\n\n\nvoid main(void){\n\n  #pragma SLOT f\n  \n  #if depthFormat( D_RGB )\n    gl_FragColor.xyz = encodeDepthRGB( ( fragZW.x / fragZW.y ) * 0.5 + 0.5 );\n    gl_FragColor.w=0.0;\n  #endif\n\n  #if depthFormat( D_DEPTH )\n    gl_FragColor = vec4( 0.0 );\n  #endif\n\n}\n"};e.toString=e,t.exports=e},398:function(t,n){var e=function(t){return"uniform vec3 uSaturation;","uniform vec3 uSaturation;"};e.toString=e,t.exports=e},399:function(t,n){var e=function(t){return"\n\nfloat gray = luminance( c );\nc = mix( vec3(gray), c, uSaturation );","\n\nfloat gray = luminance( c );\nc = mix( vec3(gray), c, uSaturation );"};e.toString=e,t.exports=e},514:function(t,n,e){"use strict";e.d(n,"a",(function(){return r}));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var i=function(t,n){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,n){t.__proto__=n}||function(t,n){for(var e in n)n.hasOwnProperty(e)&&(t[e]=n[e])})(t,n)};var o=e(318),r=(function(t){function n(n){var e=t.call(this,n)||this;return e.name="AbortError",e}(function(t,n){function e(){this.constructor=t}i(t,n),t.prototype=null===n?Object.create(n):(e.prototype=n.prototype,new e)})(n,t)}(Error),function(){function t(t){var n=this;if(this._signal=new o.a,t){Array.isArray(t)||(t=arguments);for(var e=0,i=t;e<i.length;e++){var r=i[e];r.aborted?this.abort():r.addEventListener("abort",(function(){n.abort()}))}}}return Object.defineProperty(t.prototype,"signal",{get:function(){return this._signal},enumerable:!0,configurable:!0}),t.prototype.abort=function(){Object(o.b)(this._signal)},t.timeout=function(t){var n=new o.a,e=setTimeout(o.b,t,n);return"function"==typeof e.unref&&e.unref(),n},t}())}}]);